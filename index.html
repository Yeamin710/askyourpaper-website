<script>
    // IMPORTANT: Replace with your actual N8N webhook URLs
    const initialGenerationWebhookUrl = "https://n8n-3rkg.onrender.com/webhook-test/process-document";
    const chatWebhookUrl = "https://n8n-3rkg.onrender.com/webhook-test/chat-query";

    const fileInput = document.getElementById('file-upload');
    const fileNameDisplay = document.getElementById('file-name-display');
    const urlInput = document.getElementById('url-input');
    const urlUploadBtn = document.getElementById('url-upload-btn');
    const actionButtons = document.querySelectorAll('.action-button');
    const generateBtn = document.getElementById('generate-btn');
    const loadingIndicator = document.getElementById('loading-indicator');
    const actionInstruction = document.getElementById('action-instruction');
    const chatOutputArea = document.getElementById('chat-output-area');
    const mcqOptionsContainer = document.getElementById('mcq-options');
    const difficultyButtons = document.querySelectorAll('.difficulty-button');
    
    const uploadLinkBtn = document.getElementById('upload-link-btn');
    const localUploadContainer = document.getElementById('local-upload-container');
    const urlUploadContainer = document.getElementById('url-upload-container');
    const goBackBtn = document.querySelector('.go-back-btn');

    // NEW: MCQ specific elements
    const mcqSubmitGroup = document.getElementById('mcq-submit-group');
    const submitMcqBtn = document.getElementById('submit-mcq-btn');

    // NEW: Chat specific elements
    const chatSection = document.getElementById('chat-section');
    const chatInput = document.getElementById('chat-input');
    const sendChatBtn = document.getElementById('send-chat-btn'); 
    const chatLoadingAnimation = document.getElementById('chat-loading-animation');
    const chatErrorMessage = document.getElementById('chat-error-message');


    let selectedFile = null;
    let selectedUrl = null;
    let currentMode = null;
    let selectedDifficulty = null;
    let sessionId = null; // Stores the session ID received from backend
    let isChatLoading = false; // Tracks if chat message is being sent

    // NEW: MCQ state variables
    let score = 0;
    let totalQuestions = 0;
    let userAnswers = {}; // Stores { questionIndex: selectedOptionText }
    let currentQuizQuestions = []; // Stores the actual questions data for validation

    const updateButtonState = () => {
        const isSourceSelected = selectedFile !== null || selectedUrl !== null;
        const modeIsSelected = currentMode !== null;
        let difficultySelected = true;
        if (currentMode === 'mcq') {
            difficultySelected = selectedDifficulty !== null;
        }
        generateBtn.disabled = !(isSourceSelected && modeIsSelected && difficultySelected);
    };

    actionButtons.forEach(button => {
        button.addEventListener('click', () => {
            actionButtons.forEach(btn => {
                btn.classList.remove('active');
                void btn.offsetWidth; // Force a reflow/re-render to ensure animation resets
            });

            button.classList.add('active');
            currentMode = button.getAttribute('data-mode');
            actionInstruction.classList.add('hidden');
            
            // Hide submit button when changing mode
            mcqSubmitGroup.style.display = 'none';

            if (currentMode === 'mcq') {
                mcqOptionsContainer.classList.add('visible');
                // Programmatically click "Medium" to activate its glow immediately
                const mediumButton = document.querySelector('[data-difficulty="medium"]');
                if (mediumButton) {
                    mediumButton.click(); // This will trigger its own click handler
                }
            } else {
                mcqOptionsContainer.classList.remove('visible');
                // Also remove active state from difficulty buttons when not in MCQ mode
                difficultyButtons.forEach(btn => btn.classList.remove('active'));
                selectedDifficulty = null;
            }
            
            updateButtonState();
        });
    });

    difficultyButtons.forEach(button => {
        button.addEventListener('click', () => {
            difficultyButtons.forEach(btn => {
                btn.classList.remove('active');
                void btn.offsetWidth; // Force reflow for difficulty buttons too
            });
            button.classList.add('active');
            selectedDifficulty = button.getAttribute('data-difficulty');
            updateButtonState();
        });
    });
    
    uploadLinkBtn.addEventListener('click', () => {
        localUploadContainer.classList.remove('active');
        urlUploadContainer.classList.add('active');
    });

    goBackBtn.addEventListener('click', () => {
        localUploadContainer.classList.add('active');
        urlUploadContainer.classList.remove('active');
    });

    fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            selectedFile = file;
            selectedUrl = null;
            urlInput.value = '';
            fileNameDisplay.innerText = `FILE SELECTED: ${file.name}`;
            displayChatMessage('ai', "FILE UPLOADED. SELECT AN ACTION AND CLICK 'GENERATE'.");
        } else {
            selectedFile = null;
            fileNameDisplay.innerText = "NO FILE SELECTED.";
            displayChatMessage('ai', "SELECT AN ACTION AND UPLOAD A DOCUMENT TO GET STARTED.");
        }
        updateButtonState();
    });

    urlUploadBtn.addEventListener('click', () => {
        const url = urlInput.value.trim();
        if (url) {
            selectedUrl = url;
            selectedFile = null;
            fileInput.value = '';
            fileNameDisplay.innerText = `URL SELECTED: ${url.substring(0, 50)}...`;
            displayChatMessage('ai', "URL UPLOADED. SELECT AN ACTION AND CLICK 'GENERATE'.");
        } else {
            selectedUrl = null;
            fileNameDisplay.innerText = "NO URL SELECTED.";
            displayChatMessage('ai', "SELECT AN ACTION AND UPLOAD A DOCUMENT TO GET STARTED.");
        }
        updateButtonState();
    });

    generateBtn.addEventListener('click', async () => {
        if (!selectedFile && !selectedUrl || currentMode === null) {
            displayChatMessage('ai', "PLEASE UPLOAD A FILE OR PROVIDE A URL AND SELECT AN ACTION.");
            return;
        }

        // Clear chat area and display "Generating..." message
        chatOutputArea.innerHTML = ''; 
        displayChatMessage('ai', "Generating..."); 
        loadingIndicator.classList.add('visible');
        generateBtn.disabled = true;
        actionButtons.forEach(btn => btn.disabled = true);
        urlUploadBtn.disabled = true;
        fileInput.disabled = true;
        urlInput.disabled = true;
        mcqOptionsContainer.classList.remove('visible');
        mcqSubmitGroup.style.display = 'none';
        chatInput.disabled = true; // Disable chat input during generation
        sendChatBtn.disabled = true; // Disable send button during generation


        let formData = new FormData();
        let originalFilename = '';
        let requestBody = {}; // For JSON payload

        // If a session ID already exists (e.g., from a previous interaction), pass it along
        if (sessionId) {
            requestBody.sessionId = sessionId;
            formData.append('sessionId', sessionId);
        }

        if (selectedFile) {
            formData.append('file', selectedFile);
            originalFilename = selectedFile.name;
        } else if (selectedUrl) {
            requestBody.url = selectedUrl; 
            originalFilename = selectedUrl.substring(selectedUrl.lastIndexOf('/') + 1) || 'url_document.pdf';
        }

        requestBody.mode = currentMode; 
        requestBody.filename = originalFilename; 
        if (currentMode === 'mcq') {
            requestBody.difficulty = selectedDifficulty;
        }

        let fetchOptions = {
            method: 'POST',
        };

        if (selectedFile) {
            // For file uploads, append other data to FormData
            for (const key in requestBody) {
                formData.append(key, requestBody[key]);
            }
            fetchOptions.body = formData;
        } else {
            fetchOptions.headers = {
                'Content-Type': 'application/json'
            };
            fetchOptions.body = JSON.stringify(requestBody);
        }

        try {
            const response = await fetch(initialGenerationWebhookUrl, fetchOptions);
            let rawData = await response.json(); // Get the raw response

            console.log("DEBUG: Backend Raw Response Data:", rawData); // Log the full raw response for debugging

            // IMPORTANT: Process the data received from n8n
            // The data is now directly the object, not an array.
            let processedData = {};
            if (rawData && typeof rawData === 'object') {
                processedData.sessionId = rawData["Session ID"]; // Access with space
                processedData.filename = rawData["Filename"];
                processedData.fullText = rawData["Full Text"]; // Note the space
                processedData.summary = rawData["Summary"];
                processedData.highlights = rawData["Highlights"];
                processedData.mcqs = rawData["MCQs"];
            } else {
                console.error("DEBUG: Unexpected rawData format:", rawData);
                processedData = { error: "Unexpected response format from backend." };
            }
            
            console.log("DEBUG: Frontend Processed Data:", processedData); // Log the processed data

            loadingIndicator.classList.remove('visible');
            generateBtn.disabled = false;
            actionButtons.forEach(btn => btn.disabled = false);
            urlUploadBtn.disabled = false;
            fileInput.disabled = false;
            urlInput.disabled = false;

            if (response.ok) {
                sessionId = processedData.sessionId; // Store the session ID
                console.log("DEBUG: Session ID received:", sessionId);

                // Clear "Generating..." message before displaying actual content
                chatOutputArea.innerHTML = ''; 
                console.log("DEBUG: chatOutputArea cleared. Current innerHTML:", chatOutputArea.innerHTML); // Debug clear

                if (currentMode === 'summarize') {
                    console.log("DEBUG: Attempting to display summary. Summary content:", processedData.summary); // New debug
                    displayChatMessage('ai', `SUMMARY:\n${processedData.summary || 'No summary generated.'}`);
                } else if (currentMode === 'highlight') {
                    console.log("DEBUG: Attempting to display highlights. Highlights content:", processedData.highlights); // New debug
                    displayChatMessage('ai', `HIGHLIGHTS:\n${processedData.highlights || 'No highlights generated.'}`);
                } else if (currentMode === 'mcq') {
                    currentQuizQuestions = processedData.mcqs || [];
                    if (currentQuizQuestions.length > 0) {
                        console.log("DEBUG: Attempting to display MCQs. Number of MCQs:", currentQuizQuestions.length); // New debug
                        displayMCQQuiz(currentQuizQuestions); 
                        mcqSubmitGroup.style.display = 'flex'; // Show submit button
                    } else {
                        displayChatMessage('ai', "No MCQs generated.");
                    }
                }
                
                // After successful generation, enable chat input
                chatInput.disabled = false;
                sendChatBtn.disabled = false;
                chatInput.focus(); // Focus on the chat input for immediate use
                displayChatMessage('ai', "Hello! I've processed your document. What would you like to ask about it?");


            } else {
                displayChatMessage('ai', `ERROR: ${processedData.error || 'Something went wrong.'}`);
                console.error('Backend Error:', processedData.error);
                // Keep chat disabled on error
                chatInput.disabled = true;
                sendChatBtn.disabled = true;
            }
        } catch (error) {
            loadingIndicator.classList.remove('visible');
            generateBtn.disabled = false;
            actionButtons.forEach(btn => btn.disabled = false);
            urlUploadBtn.disabled = false;
            fileInput.disabled = false;
            urlInput.disabled = false;
            displayChatMessage('ai', `NETWORK ERROR: ${error.message}. PLEASE CHECK YOUR CONNECTION OR BACKEND URL.`);
            console.error('Network or Fetch Error:', error);
            // Keep chat disabled on error
            chatInput.disabled = true;
            sendChatBtn.disabled = true;
        }
    });

    // --- MCQ Quiz Logic ---
    function displayMCQQuiz(mcqs) {
        chatOutputArea.innerHTML = ''; // Clear chat area for quiz
        displayChatMessage('ai', "Here is your MCQ quiz:"); // Announce the quiz

        score = 0;
        totalQuestions = mcqs.length;
        userAnswers = {}; // Reset user answers

        mcqs.forEach((mcq, qIndex) => {
            const questionDiv = document.createElement('div');
            questionDiv.classList.add('mcq-question');
            questionDiv.dataset.qIndex = qIndex; // Add data-q-index to questionDiv
            questionDiv.innerHTML = `<div class="mcq-question-text">Q${qIndex + 1}: ${mcq.question}</div>`;

            const optionsDiv = document.createElement('div');
            optionsDiv.classList.add('mcq-options');

            mcq.options.forEach((optionText, optIndex) => {
                const optionElement = document.createElement('div');
                optionElement.classList.add('mcq-option');
                optionElement.textContent = optionText;
                optionElement.dataset.qIndex = qIndex;
                optionElement.dataset.optIndex = optIndex;
                optionElement.addEventListener('click', handleOptionSelect);
                optionsDiv.appendChild(optionElement);
            });
            questionDiv.appendChild(optionsDiv);
            chatOutputArea.appendChild(questionDiv); // Append to chat area
        });
        chatOutputArea.scrollTop = chatOutputArea.scrollHeight; // Auto-scroll to bottom
    }

    function handleOptionSelect(event) {
        const selectedOption = event.target;
        const qIndex = selectedOption.dataset.qIndex;

        // Remove 'selected' class from other options for this question
        const questionContainer = document.querySelector(`.mcq-question[data-q-index="${qIndex}"]`);
        if (questionContainer) {
            const optionsForThisQuestion = questionContainer.querySelectorAll('.mcq-option');
            optionsForThisQuestion.forEach(opt => opt.classList.remove('selected'));
        }

        // Add 'selected' class to the clicked option
        selectedOption.classList.add('selected');
        userAnswers[qIndex] = selectedOption.textContent; // Store the selected answer
    }

    submitMcqBtn.addEventListener('click', () => {
        score = 0;
        // Recalculate score based on userAnswers and currentQuizQuestions
        currentQuizQuestions.forEach((mcq, qIndex) => {
            if (userAnswers[qIndex] && userAnswers[qIndex].startsWith(mcq.correct_answer + ")")) {
                score++;
            }
        });

        chatOutputArea.innerHTML = ''; // Clear chat area for results

        currentQuizQuestions.forEach((mcq, qIndex) => {
            const questionDiv = document.createElement('div');
            questionDiv.classList.add('mcq-question');
            questionDiv.innerHTML = `<div class="mcq-question-text">Q${qIndex + 1}: ${mcq.question}</div>`;
            
            const optionsDiv = document.createElement('div');
            optionsDiv.classList.add('mcq-options');

            mcq.options.forEach((optionText, optIndex) => {
                const optionElement = document.createElement('div');
                optionElement.classList.add('mcq-option', 'disabled'); // Disable after submission
                optionElement.textContent = optionText;

                const isCorrect = optionText.startsWith(mcq.correct_answer + ")");
                const isUserSelected = userAnswers[qIndex] === optionText;

                if (isCorrect) {
                    optionElement.classList.add('correct');
                }
                if (isUserSelected && !isCorrect) {
                    optionElement.classList.add('incorrect');
                }
                optionsDiv.appendChild(optionElement);
            });
            questionDiv.appendChild(optionsDiv);
            chatOutputArea.appendChild(questionDiv); // Append to chat area
        });

        const resultsDiv = document.createElement('div');
        resultsDiv.id = 'mcq-results';
        resultsDiv.textContent = `YOUR SCORE: ${score} / ${totalQuestions}`;
        chatOutputArea.appendChild(resultsDiv); // Append to chat area
        chatOutputArea.scrollTop = chatOutputArea.scrollHeight; // Auto-scroll to bottom

        mcqSubmitGroup.style.display = 'none'; // Hide submit button after submission
    });

    // --- Chat Logic ---
    function displayChatMessage(sender, message) {
        console.log(`DEBUG: displayChatMessage called. Sender: ${sender}, Message (first 100 chars): ${message.substring(0, Math.min(message.length, 100))}`); // New debug line
        console.log("DEBUG: chatOutputArea element:", chatOutputArea); // New debug line
        const messageBubble = document.createElement('div');
        messageBubble.classList.add('chat-message-bubble', sender); // 'user' or 'ai'

        const span = document.createElement('span');
        span.textContent = message;
        messageBubble.appendChild(span);
        console.log("DEBUG: messageBubble content before append to chatOutputArea:", messageBubble.innerHTML); // New debug line

        chatOutputArea.appendChild(messageBubble);
        chatOutputArea.scrollTop = chatOutputArea.scrollHeight; // Auto-scroll to bottom
        console.log("DEBUG: chatOutputArea content after append (first 200 chars):", chatOutputArea.innerHTML.substring(0, Math.min(chatOutputArea.innerHTML.length, 200))); // New debug line
    }

    async function handleSendChat() {
        const userMessage = chatInput.value.trim();
        if (!userMessage || !sessionId || isChatLoading) {
            return; // Don't send empty messages, or if no session, or if already loading
        }

        displayChatMessage('user', userMessage);
        chatInput.value = ''; // Clear input field
        chatErrorMessage.classList.remove('visible'); // Hide any previous error

        isChatLoading = true;
        chatInput.disabled = true;
        sendChatBtn.disabled = true;
        chatLoadingAnimation.classList.add('visible');

        try {
            const response = await fetch(chatWebhookUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    sessionId: sessionId,
                    query: userMessage,
                    filename: fileNameDisplay.innerText.replace('FILE SELECTED: ', '').replace('URL SELECTED: ', '').replace('NO FILE SELECTED.', '').replace('NO URL SELECTED.', '') // Pass filename for n8n to retrieve context
                }),
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ message: 'Unknown error' }));
                throw new Error(`HTTP error! Status: ${response.status}, Message: ${errorData.message || JSON.stringify(errorData)}`);
            }

            const data = await response.json();
            const aiResponse = data.response || "I couldn't get a clear answer. Please try rephrasing your question.";
            displayChatMessage('ai', aiResponse);

        } catch (error) {
            console.error("Error sending chat message:", error);
            chatErrorMessage.textContent = `Error: ${error.message}. Please try again.`;
            chatErrorMessage.classList.add('visible');
            displayChatMessage('ai', `Sorry, I encountered an error: "${error.message}". Please try again.`);
        } finally {
            isChatLoading = false;
            chatInput.disabled = false;
            sendChatBtn.disabled = false;
            chatLoadingAnimation.classList.remove('visible');
            chatInput.focus(); // Keep focus on chat input
        }
    }

    // Event Listeners for Chat Input
    sendChatBtn.addEventListener('click', handleSendChat);

    chatInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter' && !isChatLoading) {
            handleSendChat();
        }
    });

    // Initial state setup
    document.addEventListener('DOMContentLoaded', () => {
        updateButtonState();
        // Display initial message in the chat area
        displayChatMessage('ai', "SELECT AN ACTION AND UPLOAD A DOCUMENT TO GET STARTED.");
    });

</script>
